A* search algorithm     a* is a set of steps ( an algorithm ) that computers can use to figure out how to get somewhere fast between two places . if you have a list of locations , and how hard it is to get from one straight to the other , using a* can quickly tell you the fastest way . it 's related to dijkstra 's algorithm , but makes smart guesses so that it does n't spend as long trying slow ways . it 's a good series of steps if you only want the path between two places . if you 're going to ask for many paths from the same map , then there are faster ways , that find all the answers at once , like the floydâ€“warshall algorithm . a* will not work if you want to visit several places on one trip ( the travelling salesman problem ) . a* first needs a list of all the places you can go to , and then it needs a list of how far the road is between each one . it will then tell you the fastest way to get from place a to place z. for an example , we 'll say a is connected to places b and c , and b and c are both connected to d and e. d and e are both connected to z. there are 4 possible ways to go from a to z. you can go a-b-d-z , a-c-d-z , a-b-e-z , or a-c-e-z . a computer using a* first looks at how hard it is to get from a to b , and from a to c. this is the `` cost '' for those places . the cost of a place means how hard it is to get from a to that place . after writing down both costs , the computer looks at how hard it is to get from b to d , and adds this to b 's cost . it writes this down as d 's cost . then the computer looks at how hard it is to get from c to d , and adds this to c 's cost . this is a different cost for d , and if it 's less than the one it already has , it will replace the old one . the computer only wants to know the best path , so it ignores the path with the higher cost . it will only remember one of a-b-d and a-c-d , whichever is faster .